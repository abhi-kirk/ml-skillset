**Iterative**
- Use the bottom-up approach. 
- DP formulation:
  - Cost to reach step $n$ := Cost to reach step $(n-1)$ + Cost at step $n$. 
  - Since we are given two possibilities to take steps: one-step or two step:
    - Cost to reach step $n$ will be the minimum of the two possibilities. 
  - Starting point costs are $0$, and the ending point is 1-step outside the array (since array is 0-indexed). 
- Keep track of the costs at two previous steps, and update after DP. 
- Time Complexity: $O(n)$. 
- Space Complexity: $O(1)$. 

---

**Recursion + Memoization**
- Use recursion calls to implement the above DP formulation. 
- Memoization is used to decrease the call stack in either of the two ways:
  - Implement a global hash map, with keys as cost indices and values as the calculated DP costs. 
  - Use the in-built function decorator `@cache` in Python3. 
- Time Complexity: $O(n)$. 
- Space Complexity: $O(n)$: call stack as well as hash map. 